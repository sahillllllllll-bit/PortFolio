"use client";
import {
  ZF
} from "./chunk-BHYCE2LC.js";
import {
  require_jsx_runtime
} from "./chunk-TG2L3OCW.js";
import {
  require_react
} from "./chunk-AFOL7T4F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce;
  }
});

// node_modules/@splinetool/react-spline/dist/react-spline.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());

// node_modules/@splinetool/react-spline/dist/ParentSize.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/react-merge-refs/dist/index.mjs
function o(f2) {
  return (r) => {
    f2.forEach((n) => {
      typeof n == "function" ? n(r) : n != null && (n.current = r);
    });
  };
}

// node_modules/@splinetool/react-spline/dist/ParentSize.js
var I = [];
var K = { width: "100%", height: "100%" };
var M = (0, import_react.forwardRef)(function({
  className: w,
  children: p,
  debounceTime: i = 300,
  ignoreDimensions: s = I,
  parentSizeStyles: z2,
  enableDebounceLeadingCall: u = true,
  resizeObserverPolyfill: f2,
  ...R
}, S) {
  const o2 = (0, import_react.useRef)(null), d = (0, import_react.useRef)(0), [v, y] = (0, import_react.useState)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), n = (0, import_react.useMemo)(() => {
    const a = Array.isArray(s) ? s : [s];
    return (0, import_lodash.default)(
      (e) => {
        y((r) => Object.keys(r).filter(
          (t) => r[t] !== e[t]
        ).every(
          (t) => a.includes(t)
        ) ? r : e);
      },
      i,
      { leading: u }
    );
  }, [i, u, s]);
  return (0, import_react.useEffect)(() => {
    const a = f2 || window.ResizeObserver, e = new a((r) => {
      r.forEach((c) => {
        const { left: h, top: l2, width: t, height: A } = (c == null ? void 0 : c.contentRect) ?? {};
        d.current = window.requestAnimationFrame(() => {
          n({ width: t, height: A, top: l2, left: h });
        });
      });
    });
    return o2.current && e.observe(o2.current), () => {
      window.cancelAnimationFrame(d.current), e.disconnect(), n.cancel();
    };
  }, [n, f2]), (0, import_jsx_runtime.jsx)(
    "div",
    {
      style: { ...K, ...z2 },
      ref: o([S, o2]),
      className: w,
      ...R,
      children: p({
        ...v,
        ref: o2.current,
        resize: n
      })
    }
  );
});

// node_modules/@splinetool/react-spline/dist/react-spline.js
var G = (0, import_react2.forwardRef)(
  ({
    scene: s,
    style: u,
    onSplineMouseDown: p,
    onSplineMouseUp: b2,
    onSplineMouseHover: d,
    onSplineKeyDown: v,
    onSplineKeyUp: w,
    onSplineStart: y,
    onSplineLookAt: h,
    onSplineFollow: S,
    onSplineScroll: k2,
    onLoad: r,
    renderOnDemand: E = true,
    wasmPath: g2,
    children: x,
    ...A
  }, R) => {
    const o2 = (0, import_react2.useRef)(null), [c, a] = (0, import_react2.useState)(true), [i, j2] = (0, import_react2.useState)();
    if (i)
      throw i;
    return (0, import_react2.useEffect)(() => {
      a(true);
      let e;
      const m2 = [
        {
          name: "mouseDown",
          cb: p
        },
        {
          name: "mouseUp",
          cb: b2
        },
        {
          name: "mouseHover",
          cb: d
        },
        {
          name: "keyDown",
          cb: v
        },
        {
          name: "keyUp",
          cb: w
        },
        {
          name: "start",
          cb: y
        },
        {
          name: "lookAt",
          cb: h
        },
        {
          name: "follow",
          cb: S
        },
        {
          name: "scroll",
          cb: k2
        }
      ];
      if (o2.current) {
        e = new ZF(o2.current, {
          renderOnDemand: E,
          wasmPath: g2
        });
        async function t() {
          await e.load(s);
          for (let n of m2)
            n.cb && e.addEventListener(n.name, n.cb);
          a(false), r == null || r(e);
        }
        t().catch((n) => {
          j2(n);
        });
      }
      return () => {
        for (let t of m2)
          t.cb && e.removeEventListener(t.name, t.cb);
        e.dispose();
      };
    }, [s]), (0, import_jsx_runtime2.jsx)(
      M,
      {
        ref: R,
        parentSizeStyles: { overflow: "hidden", ...u },
        debounceTime: 50,
        ...A,
        children: () => (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
          c && x,
          (0, import_jsx_runtime2.jsx)(
            "canvas",
            {
              ref: o2,
              style: {
                display: c ? "none" : "block"
              }
            }
          )
        ] })
      }
    );
  }
);
export {
  G as default
};
//# sourceMappingURL=@splinetool_react-spline.js.map
